<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>WAFO. Description of smctpsim</title>
  <meta name="keywords" content="smctpsim">
  <meta name="description" content="  Simulates a switching Markov chain of turning points,">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="../index.html">wafo</a> &gt; <a href="index.html">wsim</a> &gt; smctpsim.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for wafo\wsim&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>smctpsim
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>  Simulates a switching Markov chain of turning points,</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong> [x,z,TT] = smctpsim(P,F,T,init,whatOut) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">SMCTPSIM</a>  Simulates a switching Markov chain of turning points,
    i.e. a switching process with a Markov chain of turning points
    within each regime.
    The switching process x has the state space {1,2,...,n} and
    the regime process z has the state space {1,2,...,r}.
 
  [x,z] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(P,F,T);
  [x,z] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(P,F,T,init);
  [x,z] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(P,F,T,init,'x');
  [RFM,RFM0,res] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(P,F,T,init,'RFM');
  [x,z,RFM] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(P,F,T,init,'x,RFM');
 
  x       = Simulated switching Markov turning points.
  z       = Simulated regime process.
  RFM     = Rainflow matrix for x.                        [n,n]
  RFM0    = Rainflow matrix for x (without the residual). [n,n]
  res     = Residual from rainflow count.                 [n,2]
 
  P       = Transition matrix for regime process.      [r,r]
  F       = Cell array of min-Max and Max-min matrices {r,2}
  F{i,1}  = min-Max matrix, process i                  [n,n]
  F{i,2}  = Max-min matrix, process i                  [n,n]
  T       = Length of simulation.
  init.x0 = Initial state of process x. If not given, it will start from
           the stationary distribution of minima given z(1).
  init.z0 = Initial state of regime process. If not given, it will start 
           from the stationary distribution of the Markov chain.
 
  If a matrix F{i,2}=[], then the process will
  be assumed to be time-reversible.
 
  One can also simulate a switching process other than Markov switching.
  In that case P is a struct array describing the switching
  P.P        = Embedded transition matrix
  P.distr    = 'exp':       Exponential distribution (Markov switching)
               'phasetype': Phasetype distribution
               'const':     Constant
               'other':     Other distribution (simTfun)
  P.simTfun  = Function for simulating occupation times.
  P.Tpar     = Parameters to distributions       {r,1}
  P.sequence = Specified sequence.               [qx2]
 
  Examples: Two regime states.
    [x,z] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(P,F,T); % Two regime states
  Example: A Markov chain of turning points (One regime state).
    [x,z] = <a href="smctpsim.html" class="code" title="  Simulates a switching Markov chain of turning points,">smctpsim</a>(1,F,T);</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="../../wafo/cycles/dtp2rfm.html" class="code" title=" [RFM,RFM1,res] = dtp2rfm(x,varargin)">dtp2rfm</a></li></TD>
<TD> Calculates rainflow matrix from discrete turning points.</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/markov/mc2stat.html" class="code" title=" [ro,PP]=mc2stat(P)">mc2stat</a></li></TD>
<TD>  Calculates the stationary distribution for a Markov chain.</TD>
</TR>
<TR>
<TD><li><a href="mcsim.html" class="code" title=" x=mcsim(P,T,x0)">mcsim</a></li></TD>
<TD>   Simulates a Markov chain.</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/markov/mctp2stat.html" class="code" title=" [ro_min,ro_max,QQ]=mctp2stat(Q)">mctp2stat</a></li></TD>
<TD>  Calculates the stationary distribution for a MCTP.</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/markov/smctp2joint.html" class="code" title=" [Q,QQ] = smctp2joint(P,F)">smctp2joint</a></li></TD>
<TD>  Calculates the joint MCTP for a SMCTP.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\timefun\clock.m">clock</a></li></TD>
<TD>         Current date and time as date vector.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\lang\error.m">error</a></li></TD>
<TD>         Display message and abort function.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graph2d\@scribehandle\isa.m">isa</a></li></TD>
<TD>           True if object is a given class.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\datatypes\iscell.m">iscell</a></li></TD>
<TD>        True for cell array.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\graph2d\@fighandle\isfield.m">isfield</a></li></TD>
<TD>       True if field is in structure array.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\strfun\@char\strcmp.bi">strcmp</a></li></TD>
<TD>        Compare strings.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\@char\tril.bi">tril</a></li></TD>
<TD>          Extract lower triangular part.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\elmat\@char\triu.bi">triu</a></li></TD>
<TD>          Extract upper triangular part.</TD>
</TR>
<TR>
<TD><li><a href="" class="code" title="C:\programs\matlab71\toolbox\matlab\lang\warning.m">warning</a></li></TD>
<TD>       Display warning message; disable or enable warning messages.</TD>
</TR>
</TABLE>
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<TABLE BORDER=0>

<TR>
<TD><li><a href="../../wafo/wdemos/itmkurs/itmkurs_lab2.html" class="code" title="This is a script file.">itmkurs_lab2</a></li></TD>
<TD> Script to computer exercises 2</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/wdemos/itmkurs/itmkurs_lab4.html" class="code" title="This is a script file.">itmkurs_lab4</a></li></TD>
<TD> Script to computer exercises 4</TD>
</TR>
<TR>
<TD><li><a href="mctpsim.html" class="code" title=" [x,out2,out3] = mctpsim(varargin)">mctpsim</a></li></TD>
<TD>  Simulates a Markov chain of turning points</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/wdemos/rfcdemo2.html" class="code" title=" [F_RFC] = refdemo2(demoNr,P,param,x0,s,lam)">rfcdemo2</a></li></TD>
<TD> Rainflow matrix for Switching Markov Chains of Turning Points.</TD>
</TR>
<TR>
<TD><li><a href="../../wafo/markov/test/test_markov.html" class="code" title="This is a script file.">test_markov</a></li></TD>
<TD> Quick test of the routines in module 'markov'</TD>
</TR>
</TABLE>

</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code"> z=init_z(S,init)</a></li><li><a href="#_sub2" class="code"> t=simT(S,z)</a></li><li><a href="#_sub3" class="code"> t=simFS(m)</a></li><li><a href="#_sub4" class="code"> t=simExp(m)</a></li><li><a href="#_sub5" class="code"> t=simPhaseType(m)</a></li><li><a href="#_sub6" class="code"> [RFM0,res,nres] = dtp2rfm_init(n)</a></li><li><a href="#_sub7" class="code"> [RFM0,res,nres] = dtp2rfm1(x,RFM0,res,nres)</a></li><li><a href="#_sub8" class="code"> [RFM] = dtp2rfm_collect(RFM0,res,nres)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <span class="keyword">function</span> [x,z,TT] = <a name="_sub0" href="#_subfunctions" class="code">smctpsim</a>(P,F,T,init,whatOut)
0002 
0003 <span class="comment">%SMCTPSIM  Simulates a switching Markov chain of turning points,</span>
0004 <span class="comment">%   i.e. a switching process with a Markov chain of turning points</span>
0005 <span class="comment">%   within each regime.</span>
0006 <span class="comment">%   The switching process x has the state space {1,2,...,n} and</span>
0007 <span class="comment">%   the regime process z has the state space {1,2,...,r}.</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% [x,z] = smctpsim(P,F,T);</span>
0010 <span class="comment">% [x,z] = smctpsim(P,F,T,init);</span>
0011 <span class="comment">% [x,z] = smctpsim(P,F,T,init,'x');</span>
0012 <span class="comment">% [RFM,RFM0,res] = smctpsim(P,F,T,init,'RFM');</span>
0013 <span class="comment">% [x,z,RFM] = smctpsim(P,F,T,init,'x,RFM');</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% x       = Simulated switching Markov turning points.</span>
0016 <span class="comment">% z       = Simulated regime process.</span>
0017 <span class="comment">% RFM     = Rainflow matrix for x.                        [n,n]</span>
0018 <span class="comment">% RFM0    = Rainflow matrix for x (without the residual). [n,n]</span>
0019 <span class="comment">% res     = Residual from rainflow count.                 [n,2]</span>
0020 <span class="comment">%</span>
0021 <span class="comment">% P       = Transition matrix for regime process.      [r,r]</span>
0022 <span class="comment">% F       = Cell array of min-Max and Max-min matrices {r,2}</span>
0023 <span class="comment">% F{i,1}  = min-Max matrix, process i                  [n,n]</span>
0024 <span class="comment">% F{i,2}  = Max-min matrix, process i                  [n,n]</span>
0025 <span class="comment">% T       = Length of simulation.</span>
0026 <span class="comment">% init.x0 = Initial state of process x. If not given, it will start from</span>
0027 <span class="comment">%          the stationary distribution of minima given z(1).</span>
0028 <span class="comment">% init.z0 = Initial state of regime process. If not given, it will start </span>
0029 <span class="comment">%          from the stationary distribution of the Markov chain.</span>
0030 <span class="comment">%</span>
0031 <span class="comment">% If a matrix F{i,2}=[], then the process will</span>
0032 <span class="comment">% be assumed to be time-reversible.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% One can also simulate a switching process other than Markov switching.</span>
0035 <span class="comment">% In that case P is a struct array describing the switching</span>
0036 <span class="comment">% P.P        = Embedded transition matrix</span>
0037 <span class="comment">% P.distr    = 'exp':       Exponential distribution (Markov switching)</span>
0038 <span class="comment">%              'phasetype': Phasetype distribution</span>
0039 <span class="comment">%              'const':     Constant</span>
0040 <span class="comment">%              'other':     Other distribution (simTfun)</span>
0041 <span class="comment">% P.simTfun  = Function for simulating occupation times.</span>
0042 <span class="comment">% P.Tpar     = Parameters to distributions       {r,1}</span>
0043 <span class="comment">% P.sequence = Specified sequence.               [qx2]</span>
0044 <span class="comment">%</span>
0045 <span class="comment">% Examples: Two regime states.</span>
0046 <span class="comment">%   [x,z] = smctpsim(P,F,T); <span class="comment">% Two regime states</span></span>
0047 <span class="comment">% Example: A Markov chain of turning points (One regime state).</span>
0048 <span class="comment">%   [x,z] = smctpsim(1,F,T);</span>
0049 
0050 <span class="comment">% Tested  on Matlab  5.3</span>
0051 <span class="comment">%</span>
0052 <span class="comment">% History:</span>
0053 <span class="comment">% Correction by PJ 20-Jan-2004</span>
0054 <span class="comment">%   Some corrections concerning initial state of regime process</span>
0055 <span class="comment">%   and simulation of non-Markovian regime process.</span>
0056 <span class="comment">% Correction by PJ 12-Aug-2002</span>
0057 <span class="comment">%   'RFM' opt didn't work cause x was not initiated. Now fixed!</span>
0058 <span class="comment">% Revised by PJ 19-May-2000</span>
0059 <span class="comment">%   Corrected method for simulating starting conditions.</span>
0060 <span class="comment">% Revised by PJ Jan-2000</span>
0061 <span class="comment">%   updated for WAFO</span>
0062 <span class="comment">% Created by PJ (Pär Johannesson) 1997</span>
0063 <span class="comment">%   Copyright (c) 1997 by Pär Johannesson</span>
0064 <span class="comment">%   Toolbox: Rainflow Cycles for Switching Processes V.1.0, 2-Oct-1997</span>
0065 
0066 TT(1,:) = clock;
0067 
0068 ni = nargin;
0069 no = nargout;
0070 error(nargchk(3,5,ni));
0071 
0072 Zstr = <span class="string">'123456789'</span>;
0073 
0074 <span class="keyword">if</span> ni &lt; 4,  init = []; <span class="keyword">end</span>
0075 <span class="keyword">if</span> ni &lt; 5,  whatOut = []; <span class="keyword">end</span>
0076 
0077 <span class="keyword">if</span> isempty(init)
0078     init.x0 = [];
0079     init.z0 = [];
0080 <span class="keyword">end</span>
0081 <span class="keyword">if</span> ~isfield(init,<span class="string">'x0'</span>), init.x0=[]; <span class="keyword">end</span>
0082 <span class="keyword">if</span> ~isfield(init,<span class="string">'z0'</span>), init.z0=[]; <span class="keyword">end</span>
0083 
0084 <span class="keyword">if</span> isempty(whatOut)
0085     whatOut = <span class="string">'x'</span>;
0086 <span class="keyword">end</span>
0087 
0088 <span class="keyword">if</span> isa(P,<span class="string">'double'</span>)
0089     Ptype = <span class="string">'P'</span>;
0090 <span class="keyword">elseif</span> isa(P,<span class="string">'struct'</span>)
0091     Ptype = <span class="string">'struct'</span>;
0092     S = P;
0093 <span class="keyword">else</span>
0094     error(<span class="string">'P should be matrix or struct-array.'</span>);
0095 <span class="keyword">end</span>
0096 
0097 r = size(F,1);   <span class="comment">% Number of regime states</span>
0098 <span class="comment">%r = length(P);   <span class="comment">% Number of regime states</span></span>
0099 
0100 n = length(F{1,1});  <span class="comment">% Number of levels</span>
0101 
0102 <span class="comment">% Check that the rowsums of P are equal to 1</span>
0103 
0104 <span class="keyword">if</span> strcmp(Ptype,<span class="string">'struct'</span>)
0105     <span class="keyword">if</span> isfield(S,<span class="string">'P'</span>)
0106         P=S.P;
0107     <span class="keyword">else</span>
0108         P=[];
0109     <span class="keyword">end</span>
0110 <span class="keyword">end</span>
0111 
0112 <span class="keyword">if</span> ~isempty(P)
0113     sumP = sum(P');
0114     <span class="keyword">if</span> sum(sumP == 1) ~= length(P)
0115         warning([<span class="string">': Rowsums of P not equal to 1. Renormalizing!'</span>]);
0116         <span class="keyword">for</span> i = 1:length(P)
0117             P(i,:) = P(i,:)/sumP(i);
0118         <span class="keyword">end</span>
0119     <span class="keyword">end</span>
0120 <span class="keyword">end</span>
0121 
0122 TT(2,:) = clock;
0123 
0124 <span class="comment">% Normalize the rowsums of F{1,1},...,F{r,1} to 1</span>
0125 <span class="comment">%  ==&gt;  Q{1,1},...,Q{r,1}</span>
0126 
0127 <span class="keyword">for</span> i = 1:r
0128     QQ{i,1} = triu(F{i,1},1); <span class="comment">% Set zeros below diagonal and diagonal</span>
0129     <span class="comment">% Set negative elements to zero</span>
0130     [I,J] = find(QQ{i,1}&lt;0);
0131     <span class="keyword">if</span> length(I) ~= 0
0132         warning([<span class="string">'Negative elements in Q'</span> Zstr(i) <span class="string">'. Setting to zero!'</span>]);
0133         <span class="keyword">for</span> k = 1:length(I)
0134             QQ{i,1}(I(k),J(k)) = 0;
0135         <span class="keyword">end</span>
0136     <span class="keyword">end</span>
0137     
0138     sumQQi = sum(QQ{i,1}');
0139     <span class="comment">% Normalize rowsums</span>
0140     <span class="keyword">if</span> sum(sumQQi == 1) ~= length(QQ{i,1})
0141         <span class="comment">%disp(['Warning: Rowsums of Q' Zstr(i) ' not equal to 1. Renormalizing!']);</span>
0142         <span class="keyword">for</span> j = 1:n-1
0143             <span class="keyword">if</span> sumQQi(j)~=0, QQ{i,1}(j,:) = QQ{i,1}(j,:)/sumQQi(j); <span class="keyword">end</span>
0144         <span class="keyword">end</span>
0145     <span class="keyword">end</span>
0146 <span class="keyword">end</span>
0147 
0148 TT(3,:) = clock;
0149 
0150 <span class="comment">% Normalize the rowsums of F{1,2},...,F{r,2} to 1</span>
0151 <span class="comment">%  ==&gt;  Q{1,2},...,Q{r,2}</span>
0152 
0153 <span class="comment">% Normalize the rowsums of Fh1,...,Fhr to 1  ==&gt;  Q1,...,Qr</span>
0154 
0155 <span class="keyword">for</span> i = 1:r
0156     <span class="keyword">if</span> isempty(F{i,2})        <span class="comment">% Time-reversible</span>
0157         QQ{i,2} = F{i,1}';
0158     <span class="keyword">else</span>
0159         QQ{i,2} = F{i,2};
0160     <span class="keyword">end</span>
0161     
0162     QQ{i,2} = tril(QQ{i,2},-1); <span class="comment">% Set zeros above diagonal and diagonal</span>
0163     <span class="comment">% Set negative elements to zero</span>
0164     [I,J] = find(QQ{i,2}&lt;0);
0165     <span class="keyword">if</span> length(I) ~= 0
0166         warning([<span class="string">'Negative elements in Qh'</span> Zstr(i) <span class="string">'. Setting to zero!'</span>]);
0167         <span class="keyword">for</span> k = 1:length(I)
0168             QQ{i,2}(I(k),J(k)) = 0;
0169         <span class="keyword">end</span>
0170     <span class="keyword">end</span>
0171     
0172     sumQQi = sum(QQ{i,2}');
0173     <span class="keyword">if</span> sum(sumQQi == 1) ~= length(QQ{i,2})
0174         <span class="comment">%disp(['Warning: Rowsums of Qh' Zstr(i) ' not equal to 1. Renormalizing!']);</span>
0175         <span class="keyword">for</span> j = 2:n
0176             <span class="keyword">if</span> sumQQi(j)~=0, QQ{i,2}(j,:) = QQ{i,2}(j,:)/sumQQi(j); <span class="keyword">end</span>
0177         <span class="keyword">end</span>
0178     <span class="keyword">end</span>
0179 <span class="keyword">end</span>
0180 
0181 TT(4,:) = clock;
0182 
0183 
0184 
0185 <span class="comment">% Initial state of z0, for regime process</span>
0186 <span class="comment">% and x0, for X-process, start from a minimum</span>
0187 
0188 <span class="comment">% Make the transition matrix Q for the joint MC (X_k,Z_k)</span>
0189 [Q] = <a href="../../wafo/markov/smctp2joint.html" class="code" title="  Calculates the joint MCTP for a SMCTP. ">smctp2joint</a>(P,QQ);
0190 
0191 <span class="comment">% Stationary distribution = ro of minima</span>
0192 [ro_min,ro_max] = <a href="../../wafo/markov/mctp2stat.html" class="code" title="  Calculates the stationary distribution for a MCTP. ">mctp2stat</a>(Q);  
0193 ro = ro_min;
0194 
0195 <span class="comment">% Start values</span>
0196 e0 = rand(1,1);  <span class="comment">% Generate random numbers</span>
0197 <span class="keyword">if</span> isempty(init.z0) &amp; isempty(init.x0)
0198     x0z0 = min(find( e0&lt;=cumsum(ro) ));
0199     x0 = floor((x0z0+1)/r);
0200     z0 = mod(x0z0-1,r)+1;
0201 <span class="keyword">elseif</span> isempty(init.x0)
0202     z0 = init.z0;
0203     rox0 = ro(z0:r:<span class="keyword">end</span>); <span class="comment">% Pick stat. distr. for regime z0</span>
0204     rox0 = rox0/sum(rox0);
0205     x0 = min(find( e0&lt;=cumsum(rox0) ));
0206 <span class="keyword">elseif</span> isempty(init.z0)
0207     x0 = init.x0;
0208     z0 = [];  <span class="comment">% Start from stat. distr of P</span>
0209 <span class="keyword">else</span> <span class="comment">% Both z0 znd x0 are given</span>
0210     x0 = init.x0;
0211     z0 = init.z0;
0212 <span class="keyword">end</span>
0213 
0214 
0215 <span class="keyword">if</span> strcmp(Ptype,<span class="string">'struct'</span>)
0216     <span class="keyword">if</span> isfield(S,<span class="string">'P'</span>)
0217         S.P=P;
0218     <span class="keyword">end</span>
0219 <span class="keyword">end</span>
0220 
0221 
0222 <span class="comment">%</span>
0223 <span class="comment">% Initiate vectors</span>
0224 <span class="comment">%</span>
0225 
0226 <span class="keyword">switch</span> whatOut
0227     
0228     <span class="keyword">case</span> {<span class="string">'x'</span>,<span class="string">'x,RFM'</span>}
0229         <span class="keyword">if</span> strcmp(Ptype,<span class="string">'P'</span>)
0230             z = <a href="mcsim.html" class="code" title="   Simulates a Markov chain.">mcsim</a>(P,T,z0);  <span class="comment">% Simulate Regime</span>
0231         <span class="keyword">else</span>
0232             z=zeros(T,1);
0233             z(1)=<a href="#_sub1" class="code" title="sub  z=init_z(S,init)">init_z</a>(S,init);
0234         <span class="keyword">end</span>
0235         e=rand(T,1);
0236         x=zeros(T,1);
0237         
0238     <span class="keyword">case</span> {<span class="string">'RFM'</span>}
0239         <span class="keyword">if</span> strcmp(Ptype,<span class="string">'P'</span>)
0240             z = <a href="mcsim.html" class="code" title="   Simulates a Markov chain.">mcsim</a>(P,1,z0);  <span class="comment">% Simulate Regime</span>
0241         <span class="keyword">else</span>
0242             z=<a href="#_sub1" class="code" title="sub  z=init_z(S,init)">init_z</a>(S,init);
0243         <span class="keyword">end</span>
0244         e=rand(1,1);
0245         
0246 <span class="keyword">end</span>
0247 
0248 x(1) = x0;
0249 
0250 TT(5,:) = clock;
0251 
0252 <span class="comment">%</span>
0253 <span class="comment">% Simulate Switching Markov turning points</span>
0254 <span class="comment">%</span>
0255 
0256 <span class="comment">% Calculate cumulative distributions</span>
0257 
0258 cumsumP = cumsum(P,2);
0259 ones_n = ones(n,1);
0260 <span class="keyword">for</span> i = 1:r 
0261     cumsumQQ{i,1} = cumsum(QQ{i,1},2);
0262     cumsumQQ{i,2} = cumsum(QQ{i,2},2);
0263     cumsumQQ{i,1}(:,<span class="keyword">end</span>) = ones_n;
0264     cumsumQQ{i,2}(:,<span class="keyword">end</span>) = ones_n;
0265 <span class="keyword">end</span>
0266 
0267 <span class="comment">% Simulate</span>
0268 
0269 <span class="keyword">switch</span> whatOut
0270     
0271     <span class="keyword">case</span> {<span class="string">'x'</span>,<span class="string">'x,RFM'</span>}
0272         <span class="keyword">switch</span> Ptype
0273             <span class="keyword">case</span> <span class="string">'P'</span>
0274                 <span class="keyword">for</span> k=2:T
0275                     <span class="keyword">if</span> rem(k,2) == 0 <span class="comment">% min-to-Max</span>
0276                         x(k) = sum( cumsumQQ{z(k),1}(x(k-1),:) &lt;= e(k) ) + 1;
0277                     <span class="keyword">else</span>             <span class="comment">% Max-to-min</span>
0278                         x(k) = sum( cumsumQQ{z(k),2}(x(k-1),:) &lt;= e(k) ) + 1;
0279                     <span class="keyword">end</span>
0280                 <span class="keyword">end</span>
0281                 
0282             <span class="keyword">case</span> <span class="string">'struct'</span>
0283                 t0 = <a href="#_sub2" class="code" title="sub  t=simT(S,z)">simT</a>(S,z(1));
0284                 <span class="keyword">for</span> k=2:T
0285                     <span class="keyword">if</span> t0 &gt; 1
0286                         z(k) = z(k-1);
0287                         t0=t0-1;
0288                     <span class="keyword">else</span>
0289                         z(k-1:k) = <a href="mcsim.html" class="code" title="   Simulates a Markov chain.">mcsim</a>(S.P,2,z(k-1));
0290                         t0 = <a href="#_sub2" class="code" title="sub  t=simT(S,z)">simT</a>(S,z(k));
0291                     <span class="keyword">end</span>
0292                     <span class="comment">%      fprintf(1,'k=%d, z=%d\n',k,z(k));</span>
0293                     <span class="keyword">if</span> rem(k,2) == 0 <span class="comment">% min-to-Max</span>
0294                         x(k) = sum( cumsumQQ{z(k),1}(x(k-1),:) &lt;= e(k) ) + 1;
0295                     <span class="keyword">else</span>             <span class="comment">% Max-to-min</span>
0296                         x(k) = sum( cumsumQQ{z(k),2}(x(k-1),:) &lt;= e(k) ) + 1;
0297                     <span class="keyword">end</span>
0298                 <span class="keyword">end</span>
0299         <span class="keyword">end</span>
0300         
0301         
0302     <span class="keyword">case</span> <span class="string">'test'</span> <span class="comment">%'x,RFM'</span>
0303         [RFM0,res,nres] = <a href="#_sub6" class="code" title="sub  [RFM0,res,nres] = dtp2rfm_init(n)">dtp2rfm_init</a>(n);
0304         [RFM0,res,nres] = <a href="#_sub7" class="code" title="sub  [RFM0,res,nres] = dtp2rfm1(x,RFM0,res,nres)">dtp2rfm1</a>(x(1),RFM0,res,nres);
0305         <span class="keyword">for</span> k=2:T
0306             e=rand(2,1);
0307             
0308             <span class="comment">% Simulate Regime</span>
0309             z(k) = sum( cumsumP(z(k-1),:) &lt;= e(1) ) + 1;
0310             
0311             <span class="comment">% Simulate MCTP</span>
0312             <span class="keyword">if</span> rem(k,2) == 0 <span class="comment">% min-to-Max</span>
0313                 x(k) = sum( cumsumQQ{z(k),1}(x(k-1),:) &lt;= e(2) ) + 1;
0314             <span class="keyword">else</span>             <span class="comment">% Max-to-min</span>
0315                 x(k) = sum( cumsumQQ{z(k),2}(x(k-1),:) &lt;= e(2) ) + 1;
0316             <span class="keyword">end</span>
0317             [RFM0,res,nres] = <a href="#_sub7" class="code" title="sub  [RFM0,res,nres] = dtp2rfm1(x,RFM0,res,nres)">dtp2rfm1</a>(x(k),RFM0,res,nres);
0318         <span class="keyword">end</span>
0319         [RFM] = <a href="#_sub8" class="code" title="sub  [RFM] = dtp2rfm_collect(RFM0,res,nres)">dtp2rfm_collect</a>(RFM0,res,nres);
0320         
0321     <span class="keyword">case</span> <span class="string">'RFM'</span>
0322         [RFM0,res,nres] = <a href="#_sub6" class="code" title="sub  [RFM0,res,nres] = dtp2rfm_init(n)">dtp2rfm_init</a>(n);
0323         [RFM0,res,nres] = <a href="#_sub7" class="code" title="sub  [RFM0,res,nres] = dtp2rfm1(x,RFM0,res,nres)">dtp2rfm1</a>(x,RFM0,res,nres);
0324         <span class="keyword">for</span> k=2:T
0325             e=rand(2,1);
0326             
0327             <span class="comment">% Simulate Regime</span>
0328             z = sum( cumsumP(z,:) &lt;= e(1) ) + 1;
0329             
0330             <span class="comment">% Simulate MCTP</span>
0331             <span class="keyword">if</span> rem(k,2) == 0 <span class="comment">% min-to-Max</span>
0332                 x = sum( cumsumQQ{z,1}(x,:) &lt;= e(2) ) + 1;
0333             <span class="keyword">else</span>             <span class="comment">% Max-to-min</span>
0334                 x = sum( cumsumQQ{z,2}(x,:) &lt;= e(2) ) + 1;
0335             <span class="keyword">end</span>
0336             [RFM0,res,nres] = <a href="#_sub7" class="code" title="sub  [RFM0,res,nres] = dtp2rfm1(x,RFM0,res,nres)">dtp2rfm1</a>(x,RFM0,res,nres);
0337         <span class="keyword">end</span>
0338         [RFM] = <a href="#_sub8" class="code" title="sub  [RFM] = dtp2rfm_collect(RFM0,res,nres)">dtp2rfm_collect</a>(RFM0,res,nres);
0339         
0340 <span class="keyword">end</span>
0341 
0342 TT(6,:) = clock;
0343 
0344 <span class="comment">% Output arguments</span>
0345 
0346 <span class="keyword">switch</span> whatOut
0347     <span class="keyword">case</span> <span class="string">'x,RFM'</span>
0348         RFM = <a href="../../wafo/cycles/dtp2rfm.html" class="code" title=" Calculates rainflow matrix from discrete turning points.">dtp2rfm</a>(x,n);
0349         TT = RFM;
0350     <span class="keyword">case</span> <span class="string">'RFM'</span>
0351         x = RFM;
0352 <span class="keyword">end</span>
0353 
0354 
0355 <span class="keyword">function</span> z=<a name="_sub1" href="#_subfunctions" class="code">init_z</a>(S,init)
0356 
0357 <span class="comment">% Initiate regime.</span>
0358 
0359 <span class="keyword">if</span> isempty(init.z0)
0360     r=length(S.P);
0361     m = zeros(1,r);
0362     <span class="keyword">switch</span> S.distr
0363         <span class="keyword">case</span> {<span class="string">'exp'</span>,<span class="string">'const'</span>},
0364             <span class="keyword">for</span> i=1:r, m(i)=S.Tpar{i}; <span class="keyword">end</span>
0365         <span class="keyword">case</span> <span class="string">'phasetype'</span>,
0366             <span class="keyword">for</span> i=1:r, m(i)=sum(S.Tpar{i}); <span class="keyword">end</span>
0367         <span class="keyword">end</span>
0368         statP=<a href="../../wafo/markov/mc2stat.html" class="code" title="  Calculates the stationary distribution for a Markov chain.">mc2stat</a>(S.P);
0369         ro = statP.*m;
0370         z = sum( cumsum(ro) &lt;= rand ) + 1;
0371     <span class="keyword">else</span>
0372         z=init.z0;
0373     <span class="keyword">end</span>
0374     
0375     
0376     <span class="keyword">function</span> t=<a name="_sub2" href="#_subfunctions" class="code">simT</a>(S,z)
0377     
0378     <span class="comment">% Simulate occupation time.</span>
0379     
0380     <span class="keyword">if</span> iscell(S.distr)
0381         distr = S.distr{z};
0382     <span class="keyword">else</span>
0383         distr = S.distr;
0384     <span class="keyword">end</span>
0385     
0386     <span class="keyword">switch</span> distr
0387         
0388         <span class="keyword">case</span> <span class="string">'exp'</span>
0389             t = <a href="#_sub3" class="code" title="sub  t=simFS(m)">simFS</a>(S.Tpar{z});
0390         <span class="keyword">case</span> <span class="string">'phasetype'</span>
0391             t = <a href="#_sub5" class="code" title="sub  t=simPhaseType(m)">simPhaseType</a>(S.Tpar{z});
0392         <span class="keyword">case</span> <span class="string">'const'</span>
0393             t = S.Tpar{z};
0394         <span class="keyword">case</span> <span class="string">'other'</span>
0395             error(<span class="string">'other: Not yet implemented.'</span>);
0396     <span class="keyword">end</span>
0397     
0398     <span class="comment">% Simulate First Success R.V.</span>
0399     
0400     <span class="keyword">function</span> t=<a name="_sub3" href="#_subfunctions" class="code">simFS</a>(m)
0401     <span class="comment">% Simulation method taken from stats-toolbox 'geornd'</span>
0402     
0403     u = rand(size(m));
0404     p = 1./m;
0405     t = floor(log(u) ./ log(1 - p)) + 1;
0406     <span class="comment">%t = - m .* log(rand(size(m)));</span>
0407     
0408     <span class="comment">% Simulate Exponential R.V.</span>
0409     <span class="keyword">function</span> t=<a name="_sub4" href="#_subfunctions" class="code">simExp</a>(m)
0410     
0411     t = - m .* log(rand(size(m)));
0412     
0413     <span class="comment">% Simulate discrete Phasetype R.V.</span>
0414     
0415     <span class="keyword">function</span> t=<a name="_sub5" href="#_subfunctions" class="code">simPhaseType</a>(m)
0416     
0417     t = sum(<a href="#_sub3" class="code" title="sub  t=simFS(m)">simFS</a>(m));
0418     <span class="comment">%t = sum(simExp(m));</span>
0419     
0420     <span class="comment">% Description of variables for  dtp2rfm</span>
0421     <span class="comment">%</span>
0422     <span class="comment">% RFM   = Rainflow Matrix (residual included).    [nxn]</span>
0423     <span class="comment">% RFM0  = Rainflow matrix (without resudual).     [nxn]</span>
0424     <span class="comment">% res   = Residual.                               [2*n,1]</span>
0425     <span class="comment">% nres  = Length of residual</span>
0426     <span class="comment">% x     = Turning points (taking values 1,...,n). [T,1]</span>
0427     <span class="comment">% n     = Number of levels.</span>
0428     
0429     <span class="keyword">function</span> [RFM0,res,nres] = <a name="_sub6" href="#_subfunctions" class="code">dtp2rfm_init</a>(n)
0430     
0431     <span class="comment">% Initiate variables RFM0,res,nres</span>
0432     
0433     RFM0 = zeros(n);
0434     res = zeros(2*n+1,1);
0435     nres = 0;
0436     
0437     
0438     <span class="keyword">function</span> [RFM0,res,nres] = <a name="_sub7" href="#_subfunctions" class="code">dtp2rfm1</a>(x,RFM0,res,nres)
0439     
0440     <span class="comment">% Count one TP.</span>
0441     
0442     
0443     <span class="comment">% Calculate RFM and res</span>
0444     
0445     <span class="comment">%for i = 1:length(x)</span>
0446     nres = nres+1;
0447     res(nres) = x; <span class="comment">%(i);</span>
0448     cycleFound = 1;
0449     <span class="keyword">while</span> cycleFound==1 &amp; nres&gt;=4
0450         A = sort([res(nres-1) res(nres-2)]);
0451         B = sort([res(nres) res(nres-3)]);
0452         <span class="keyword">if</span> A(1) &gt;= B(1) &amp; A(2) &lt;= B(2)
0453             RFM0(res(nres-2),res(nres-1)) = RFM0(res(nres-2),res(nres-1)) + 1;
0454             res(nres-2) = res(nres);
0455             nres = nres-2;
0456         <span class="keyword">else</span>
0457             cycleFound = 0;
0458         <span class="keyword">end</span>
0459     <span class="keyword">end</span>
0460     <span class="comment">%end</span>
0461     
0462     
0463     
0464     <span class="keyword">function</span> [RFM] = <a name="_sub8" href="#_subfunctions" class="code">dtp2rfm_collect</a>(RFM0,res,nres)
0465     
0466     <span class="comment">% Collect RFM0 and residuals. Store in RFM.</span>
0467     
0468     
0469     <span class="comment">% Calculate RFM = RFM0 + 'cycles in res'</span>
0470     
0471     RFM = RFM0;
0472     <span class="keyword">for</span> i=1:2:nres-1
0473         RFM(res(i),res(i+1)) = RFM(res(i),res(i+1)) + 1;
0474     <span class="keyword">end</span>
0475     
0476     <span class="comment">% Convert to symetric rainflow</span>
0477     
0478     RFM = RFM+RFM';
0479     RFM = triu(RFM);
0480     
0481</pre></div>
<HR noShade>
<SMALL><A href="http://www.maths.lth.se/matstat/">Mathematical 
Statistics</A><BR><A href="http://www.maths.lth.se/">Centre for Mathematical 
Sciences</A><BR><A href="http://www.lu.se/">Lund University</A> with <A 
href="http://www.lth.se/">Lund Institute of Technology</A> </SMALL>
<P><SMALL>Comments or corrections to the <A
href="mailto:wafo@maths.lth.se">WAFO group</A>  </P>

<hr><address>Generated on Thu 06-Oct-2005 02:21:16
 for <strong><A href="http://www.maths.lth.se/matstat/wafo/">WAFO</A></strong>
 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>